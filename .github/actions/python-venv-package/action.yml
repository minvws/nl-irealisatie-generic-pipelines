name: "Python venv packager"
description: "Exports a Python venv package with the needed requirements installed"
inputs:
  python_version:
    description: "Python version"
    required: true
  package_file_name:
    description: "Name of the package"
    required: true
  checkout_repository:
    description: "Whether to checkout the repository (true or false)"
    required: false
    default: 'true'
  working_directory:
    description: "Working directory containing a requirements.txt or poetry.lock file"
    required: false
    default: '.'

runs:
  using: "composite"
  steps:
    - name: Set release version
      shell: bash
      run: echo "RELEASE_VERSION=${GITHUB_REF#refs/*/}" >> $GITHUB_ENV

    - name: Set package file name
      shell: bash
      run: echo "PACKAGE_FILE_NAME=${{ inputs.package_file_name }}_venv_${{ env.RELEASE_VERSION }}_python${{ inputs.python_version }}" >> $GITHUB_ENV

    - name: Checkout code
      if: ${{ inputs.checkout_repository == 'true' }}
      uses: actions/checkout@v4

    - name: Setup python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ inputs.python_version }}

    - name: Check if requirements file exists
      id: check_requirements_file
      shell: bash
      run: |
        if [ -f "${{ inputs.working_directory }}/requirements.txt" ]; then
          echo "::notice::requirements.txt file exists"
          echo "file_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::notice::requirements.txt file does not exist"
          echo "file_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Check if poetry.lock file exists
      id: check_poetry_file
      shell: bash
      run: |
        if [ -f "${{ inputs.working_directory }}/poetry.lock" ]; then
          echo "::notice::poetry.lock file exists"
          echo "file_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::notice::poetry.lock file does not exist"
          echo "file_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Export requirements (when Poetry)
      if: |
        steps.check_poetry_file.outputs.file_exists == 'true' &&
        steps.check_requirements_file.outputs.file_exists == 'false'
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        pip3 install poetry
        poetry self add poetry-plugin-export
        poetry export > requirements.txt

    - name: Exit if requirements.txt file does not exist
      shell: bash
      run: |
        if [ ! -f "${{ inputs.working_directory }}/requirements.txt" ]; then
          echo "::error::requirements.txt file does not exist"
          exit 1
        fi

    - name: Create venv
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        python -m venv .venv
        . .venv/bin/activate
        pip install -r requirements.txt

    - name: Fix python3 symlink - back to default location
      working-directory: ${{ inputs.working_directory }}
      shell: bash
      run: cd .venv/bin && rm python3 python && ln -s /usr/bin/python3 python3 && ln -s /usr/bin/python python

    - name: Add version file
      working-directory: ${{ inputs.working_directory }}
      shell: bash
      run: 'echo "{ \"version\": \"${{ env.RELEASE_VERSION }}\", \"git_ref\": \"$GITHUB_SHA\"}" > .venv/version.json'

    - name: Create archive
      working-directory: ${{ inputs.working_directory }}
      shell: bash
      run: tar -czf ${{ env.PACKAGE_FILE_NAME }}.tar.gz .venv

    - name: Upload venv tar
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PACKAGE_FILE_NAME }}
        path: ${{ inputs.working_directory }}/${{ env.PACKAGE_FILE_NAME }}.tar.gz
